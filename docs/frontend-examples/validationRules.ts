/**
 * Frontend Validation Rules Synchronization
 * 
 * This file provides TypeScript types and utilities to sync with
 * Backend DomainRules.cs via API endpoint /api/validation-rules
 * 
 * ⚠️ IMPORTANT: 
 * - Run `npm run sync-validation-rules` to fetch latest rules from backend
 * - Do NOT manually edit ValidationRules object - it will be overwritten
 */

// ============================================================================
// TypeScript Types matching Backend DomainRules
// ============================================================================

export interface UsernameRules {
  minLength: number;
  maxLength: number;
  pattern: string;
  allowedCharacters: string;
}

export interface PasswordRules {
  minLength: number;
  maxLength: number;
  specialCharacters: string;
  patterns: {
    uppercase: string;
    lowercase: string;
    digit: string;
    special: string;
  };
}

export interface EmailRules {
  maxLength: number;
  description: string;
}

export interface PhoneNumberRules {
  minLength: number;
  maxLength: number;
  defaultCountryCode: string;
  description: string;
}

export interface PostalCodeRules {
  maxLength: number;
  description: string;
}

export interface AddressRules {
  streetMaxLength: number;
  cityMaxLength: number;
  countryCodeLength: number;
  description: string;
}

export interface DomainNameRules {
  maxLength: number;
  pattern: string;
  description: string;
}

export interface RoleCodeRules {
  maxLength: number;
  pattern: string;
  allowedCharacters: string;
  description: string;
}

export interface TaxCodeRules {
  minLength: number;
  maxLength: number;
  pattern: string;
  allowedCharacters: string;
  description: string;
}

export interface RatingRules {
  minValue: number;
  maxValue: number;
  description: string;
}

export interface PercentageRules {
  minValue: number;
  maxValue: number;
  description: string;
}

export interface ValidationRulesResponse {
  username: UsernameRules;
  password: PasswordRules;
  email: EmailRules;
  phoneNumber: PhoneNumberRules;
  postalCode: PostalCodeRules;
  address: AddressRules;
  domainName: DomainNameRules;
  roleCode: RoleCodeRules;
  taxCode: TaxCodeRules;
  rating: RatingRules;
  percentage: PercentageRules;
}

// ============================================================================
// Validation Rules Fetcher
// ============================================================================

const VALIDATION_RULES_API = '/api/validation-rules';
const CACHE_KEY = 'validationRules';
const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours

/**
 * Fetch validation rules from backend API
 * Automatically caches result in localStorage for 24 hours
 */
export async function fetchValidationRules(): Promise<ValidationRulesResponse> {
  // Check cache first
  const cached = localStorage.getItem(CACHE_KEY);
  if (cached) {
    const { data, timestamp } = JSON.parse(cached);
    if (Date.now() - timestamp < CACHE_DURATION) {
      console.log('[ValidationRules] Loaded from cache');
      return data;
    }
  }

  // Fetch from API
  console.log('[ValidationRules] Fetching from API...');
  const response = await fetch(VALIDATION_RULES_API);
  if (!response.ok) {
    throw new Error(`Failed to fetch validation rules: ${response.statusText}`);
  }

  const data: ValidationRulesResponse = await response.json();

  // Cache the result
  localStorage.setItem(CACHE_KEY, JSON.stringify({
    data,
    timestamp: Date.now()
  }));

  console.log('[ValidationRules] Fetched and cached successfully');
  return data;
}

/**
 * Clear cached validation rules
 * Use this after backend deployment to force refresh
 */
export function clearValidationRulesCache(): void {
  localStorage.removeItem(CACHE_KEY);
  console.log('[ValidationRules] Cache cleared');
}

// ============================================================================
// Validation Rules (Auto-generated - Do NOT manually edit)
// ============================================================================

/**
 * ⚠️ This object is auto-generated by fetching from backend
 * Run: npm run sync-validation-rules
 * 
 * Last synced: 2025-01-XX XX:XX:XX
 */
export const ValidationRules = {
  Username: {
    minLength: 3,
    maxLength: 50,
    pattern: /^[a-zA-Z0-9._-]+$/,
    allowedCharacters: 'letters, numbers, dots (.), underscores (_), and hyphens (-)',
    
    isValidFormat(username: string): boolean {
      return this.pattern.test(username);
    }
  },
  
  Password: {
    minLength: 8,
    maxLength: 128,
    patterns: {
      uppercase: /[A-Z]/,
      lowercase: /[a-z]/,
      digit: /[0-9]/,
      special: /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/,
    },
    specialCharacters: '!@#$%^&*()_+-=[]{}; \':"\\|,.<>/?',
    
    hasUppercase(password: string): boolean {
      return this.patterns.uppercase.test(password);
    },
    hasLowercase(password: string): boolean {
      return this.patterns.lowercase.test(password);
    },
    hasDigit(password: string): boolean {
      return this.patterns.digit.test(password);
    },
    hasSpecialChar(password: string): boolean {
      return this.patterns.special.test(password);
    },
    isValid(password: string): boolean {
      return this.hasUppercase(password) 
        && this.hasLowercase(password)
        && this.hasDigit(password) 
        && this.hasSpecialChar(password);
    }
  },
  
  Email: {
    maxLength: 256,
    
    isValidFormat(email: string): boolean {
      // Use browser's built-in email validation
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(email);
    }
  },
  
  PhoneNumber: {
    minLength: 9,
    maxLength: 15,
    defaultCountryCode: '+84',
    
    isValidLength(phone: string): boolean {
      const digitsOnly = phone.replace(/\D/g, '');
      return digitsOnly.length >= this.minLength && digitsOnly.length <= this.maxLength;
    }
  },

  PostalCode: {
    maxLength: 10,
  },

  TaxCode: {
    minLength: 8,
    maxLength: 15,
    pattern: /^[0-9\-]+$/,
    allowedCharacters: 'numbers (0-9) and hyphens (-)',
    
    isValidFormat(taxCode: string): boolean {
      return this.pattern.test(taxCode);
    }
  },

  Rating: {
    minValue: 1,
    maxValue: 5,
    
    isValid(rating: number): boolean {
      return rating >= this.minValue && rating <= this.maxValue;
    }
  },

  Percentage: {
    minValue: 0,
    maxValue: 100,
    
    isValid(percentage: number): boolean {
      return percentage >= this.minValue && percentage <= this.maxValue;
    }
  }
};

// ============================================================================
// Client-side Validation Helpers (Using Error Codes)
// ============================================================================

/**
 * Validate username and return error code if invalid
 * @returns Error code or null if valid
 */
export function validateUsername(username: string): string | null {
  if (!username || username.trim() === '') return 'VO_USERNAME_EMPTY';
  if (username.length < ValidationRules.Username.minLength) return 'VO_USERNAME_TOO_SHORT';
  if (username.length > ValidationRules.Username.maxLength) return 'VO_USERNAME_TOO_LONG';
  if (!ValidationRules.Username.isValidFormat(username)) return 'VO_USERNAME_INVALID';
  return null;
}

/**
 * Validate password and return error code if invalid
 * @returns Error code or null if valid
 */
export function validatePassword(password: string): string | null {
  if (!password || password.trim() === '') return 'VO_PASSWORD_EMPTY';
  if (password.length < ValidationRules.Password.minLength) return 'VO_PASSWORD_TOO_SHORT';
  if (password.length > ValidationRules.Password.maxLength) return 'VO_PASSWORD_TOO_LONG';
  if (!ValidationRules.Password.hasUppercase(password)) return 'VO_PASSWORD_NO_UPPERCASE';
  if (!ValidationRules.Password.hasLowercase(password)) return 'VO_PASSWORD_NO_LOWERCASE';
  if (!ValidationRules.Password.hasDigit(password)) return 'VO_PASSWORD_NO_DIGIT';
  if (!ValidationRules.Password.hasSpecialChar(password)) return 'VO_PASSWORD_NO_SPECIAL';
  return null;
}

/**
 * Validate email and return error code if invalid
 * @returns Error code or null if valid
 */
export function validateEmail(email: string): string | null {
  if (!email || email.trim() === '') return 'VO_EMAIL_EMPTY';
  if (email.length > ValidationRules.Email.maxLength) return 'VO_EMAIL_TOO_LONG';
  if (!ValidationRules.Email.isValidFormat(email)) return 'VO_EMAIL_INVALID';
  return null;
}

/**
 * Validate phone number and return error code if invalid
 * @returns Error code or null if valid
 */
export function validatePhoneNumber(phone: string): string | null {
  if (!phone || phone.trim() === '') return 'VO_PHONE_EMPTY';
  if (!ValidationRules.PhoneNumber.isValidLength(phone)) return 'VO_PHONE_INVALID';
  return null;
}

/**
 * Get validation details for error message translation
 */
export function getValidationDetails(errorCode: string, value: string): Record<string, any> {
  switch (errorCode) {
    case 'VO_USERNAME_TOO_SHORT':
    case 'VO_USERNAME_TOO_LONG':
      return {
        field: 'Username',
        minLength: ValidationRules.Username.minLength,
        maxLength: ValidationRules.Username.maxLength,
        actualLength: value.length
      };
    
    case 'VO_USERNAME_INVALID':
      return {
        field: 'Username',
        allowedChars: ValidationRules.Username.allowedCharacters
      };
    
    case 'VO_PASSWORD_TOO_SHORT':
    case 'VO_PASSWORD_TOO_LONG':
      return {
        field: 'Password',
        minLength: ValidationRules.Password.minLength,
        maxLength: ValidationRules.Password.maxLength,
        actualLength: value.length
      };
    
    case 'VO_PASSWORD_NO_UPPERCASE':
      return {
        field: 'Password',
        requirement: 'uppercase letter (A-Z)'
      };
    
    case 'VO_PASSWORD_NO_LOWERCASE':
      return {
        field: 'Password',
        requirement: 'lowercase letter (a-z)'
      };
    
    case 'VO_PASSWORD_NO_DIGIT':
      return {
        field: 'Password',
        requirement: 'digit (0-9)'
      };
    
    case 'VO_PASSWORD_NO_SPECIAL':
      return {
        field: 'Password',
        requirement: 'special character',
        allowedChars: ValidationRules.Password.specialCharacters
      };
    
    case 'VO_EMAIL_TOO_LONG':
      return {
        field: 'Email',
        maxLength: ValidationRules.Email.maxLength,
        actualLength: value.length
      };
    
    case 'VO_PHONE_INVALID':
      return {
        field: 'Phone Number',
        minLength: ValidationRules.PhoneNumber.minLength,
        maxLength: ValidationRules.PhoneNumber.maxLength
      };
    
    default:
      return { field: 'Field' };
  }
}

// ============================================================================
// Usage Example
// ============================================================================

/**
 * Example: Validate form field and get translated error message
 */
/*
import { validateUsername, getValidationDetails } from './validationRules';
import { useTranslation } from 'react-i18next';

function UsernameField() {
  const { t } = useTranslation();
  const [error, setError] = useState('');
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const username = e.target.value;
    const errorCode = validateUsername(username);
    
    if (errorCode) {
      const details = getValidationDetails(errorCode, username);
      const message = t(`errors.${errorCode}`, details);
      setError(message);
    } else {
      setError('');
    }
  };
  
  return (
    <div>
      <input type="text" onChange={handleChange} />
      {error && <span className="error">{error}</span>}
    </div>
  );
}
*/
